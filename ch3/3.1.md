# 简介

$$
\min \left\| Ax - b\right\|_2
$$ 

* $$A_{m\times n}$$ 
* $$b_{n\times 1}$$
* $$m > n$$, 超定问题(overdetermined)
* $$m < n$$, 欠定问题(underdetermined)

**例子 3.1** 曲线拟合问题

给定一组数据点
$$
(y_1, b_1), \ldots, (y_m, b_m)
$$ 

找到一个“最好”的三次多项式，拟合 $$b_i$$ 为 $$y_i$$ 的函数。


```python
# numpy.polyfit(x, y, deg)
>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
>>> z = np.polyfit(x, y, 3)
>>> z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])
```

* 上面拟合的多项式中 $$1, x, x^2, \cdots, x^k$$ 

```python
import numpy as np
import matplotlib.pyplot as plt

f = lambda y: np.sin(np.pi*y/5) + y/5
y = np.linspace(-5, 6, num=23)
b = f(y)
deg = [1, 3, 6, 19, 30]
p =[]
for d in deg:
    p.append(np.polyfit(y, b, d))
print(p[3])

fig = plt.figure()
axes = fig.gca()
# plot the true function
y1 = np.linspace(-5, 6, num=1000)
axes.set_xlim((-10, 10))
axes.set_ylim((-3, 3))
axes.set_aspect('auto')
axes.plot(y1, f(y1))

# plot the fit polynomial
y2 = np.linspace(-10, 10, num=1000)
for p0 in p:
    print(len(p0))
    b2 = np.polyval(p0, y2)
    axes.plot(y2, b2, label=str(len(p0)-1))
axes.plot(y, b,'ko',label='raw data')
axes.legend()


p = []
for d in range(1, 20):
    p.append(np.poly1d(np.polyfit(y, b, d)))
    
r = np.zeros((19,))
for i in range(0, 19):
    r[i] = np.linalg.norm(p[i](y) - b, 2)
fig1 = plt.figure()
axes1 = fig1.gca()
axes1.set_ylim((0, 0.01))
axes1.plot(range(1, 20), r, 'k+')
```



